# CPP+OPENGL 2D游戏引擎开发记录

## 1.明确我要干什么

### 1.1CPP+OPENGL引擎的目的：

​	首先要明确，我计划做出一个我自己（也许会有其他人）使用的引擎，只需要在windows下运行，只需要做2D游戏，有编程基础，这样就减少了很多成熟的引擎需要而我不需要的工作量，比如UI界面，3D，平台层等等等等。

​	这个引擎叫做CPP+OPENGL引擎，我决定叫它CO引擎（>▽<）！

### 1.2游戏引擎

​	游戏引擎可以分为几层呢？

​	依照**GAMES**1.4课程的说法,游戏引擎包含平台层(忽略),核心层:包括数学库,数据结构,内存管理机制等等开发需要的工具,这方面我打算先用C++内置的STL库来实现,换句话说就是不实现,等到最后再慢慢优化.资源层,功能层和工具层

​	依照这个逻辑,我把我要做的引擎也分为若干层:

​	应用层:最上面的一层,在这里我要直接操作GameObject及其组件的各项属性,调整摄像机和窗口大小,设置他们的行为,加载资源,换句话说就是其它引擎的用户接触到的这一层.

​	功能层:我在这里制作出各个组件,例如碰撞器,触发器的"原件",为他们设置好有什么属性等等等等.这些组件可以简单的在工具层调用并且设置属性.可想而知这里应该有很多类的继承关系.opengl应该是我在这一层会使用的主要工具之一

​	资源层:我要在这里把图片(材质),动画,模型,声音等等处理成方便计算机处理的格式,并且分配一个GUID,妥善地保存起来,使其方便被上面的层使用.我应该会使用诸多现成的库.

​	可见,游戏引擎的本体只是功能和资源层.

### 1.3开发计划

​	我打算先开始制作功能层,先使用复杂一点的方式加载资源,然后在制作资源层,接着试着用这些制作几个简单的游戏,最后在改善核心层

## 2.功能层的开发

### 2.1GameObject

一个gameobject包含什么呢？

​	首先是他的位置，其次就是他身上挂的组件，此外还有它的名字，父子关系等等等等。

​	我先从组件开始吧

### 2.2Component

组件有很多，一下子能想出来的有Renderer，Collider，Script和RigidBody。我不妨将他们定义为一个Component父类下的子类，这样我就可以在gameobject里使用类似

```C++
//...
vector<Component> components;
//...

componets[i].dosomething();
```

的方法来调用这些组件

Comonent的属性应该包含什么呢

首先应该是一个bool变量，表示这个组件有没有在激活

其次我打算设定一个枚举变量，来表示组件具体是哪一种组件

最后，设定一个虚函数，用来“dosomething”

暂时想到这些，开始写吧。

```C++
#pragma once
enum class ComponentType {
	COMPONENT,
	RENDERER,
	COLLIDER,
	RIGIDBODY,
	SCRIPT
};
class Component
{
protected:
	ComponentType comtype;
public:
	bool active;
	Component();
	bool Isactive();
	virtual void dosomething();
};
//值得一提的是，enum class 是C++11的新特性，使用方法是comtype = ComponentType::COMPONENT;这样

```

### 2.3搭出GameObject类

有泪component，就准备好GameObject（从代码上讲）需要的所有东西了，之后就准备写GameObject吧！

首先他要可以使用Component，因此要设定一个Component组，当然他们是不可以重复的。

有没有这种数据结构呢？有，set！（所以上面的写法是错的哈哈哈哈）

为了让set区分两个Component对象，我们给Component类重载一下运算符.

```c++
bool operator == ( const Component &b) const{
		return comtype == b.comtype;
	}
	bool operator> (const Component& b) const {
		return comtype > b.comtype;
	}
```

ok，那么GameObject类大概长成这样

```C++
class GameObject
{
private:
	GameObject* father;
	std::list<GameObject> son;
	std::set<Component> components;
public:
	std::string name;
	GameObject();
	float width;
	float height;
	float angle;
	glm::vec3 position;
	void Translate(float deltaX,float deltaY);
	void Rotate(float deltaA);
	void Scale(float dwidth, float dheight);
};
```

还有好多方法没有写，我决定以后再做。目前实现的方法都很简单，简单的入参校验+四则运算即可。

### 2.4实现其它Component

#### 2.4.1Renderer渲染器

装备了渲染器的GameObject可以被画出来，不难想出来Renderer要实现画一个物体的功能

我希望到时候这样

```
while(1){//主循环
	//...
	GameObject.getRenderer().draw();
	//...
}
```

就可以画出一个GameObject。

因为我是彩笔，所以我先只画一个正方形。（长方形？）

他应该包含一个纹理，着色器，VAO，这就是要做的工作了。之后会把纹理和shader（也许还有VAO）交由一个全局的Manager管理，现在就先交给用户做吧www。

2023.9.17遇到了意料之外的bug，我决定放弃用一个component集合来解决这个问题。

```C++
void Renderer::InitRenderer()
{
	GLfloat vertices[] = {
		// 位置     // 纹理
		0.0f, 1.0f, 0.0f, 1.0f,
		1.0f, 0.0f, 1.0f, 0.0f,
		0.0f, 0.0f, 0.0f, 0.0f,

		0.0f, 1.0f, 0.0f, 1.0f,
		1.0f, 1.0f, 1.0f, 1.0f,
		1.0f, 0.0f, 1.0f, 0.0f
	};
	GLuint VBO;
	glGenVertexArrays(1, &this->VAO);
	glGenBuffers(1, &VBO);
	glBindBuffer(GL_ARRAY_BUFFER, VBO);
	glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
	glBindVertexArray(this->VAO);
	glEnableVertexAttribArray(0);
	glVertexAttribPointer(0, 4, GL_FLOAT, GL_FALSE, 4 * sizeof(GLfloat), (GLvoid*)0);
	glBindBuffer(GL_ARRAY_BUFFER, 0);
	glBindVertexArray(0);
}

void Renderer::draw(glm::vec3 position, glm::vec2 size, float rotate,glm::vec3 color)
{
	shader.use();
	glm::mat4 model(1.0);
	model = glm::translate(model, position);

	model = glm::translate(model, glm::vec3(0.5f * size.x, 0.5f * size.y, 0.0f));
	model = glm::rotate(model, rotate, glm::vec3(0.0f, 0.0f, 1.0f));
	model = glm::translate(model, glm::vec3(-0.5f * size.x, -0.5f * size.y, 0.0f));

	model = glm::scale(model, glm::vec3(size, 1.0f));

	shader.setMat4("model", model);
	shader.setBool("enableTexture", enableTexture);
	shader.setVec3("spriteColor", color);
	if(enableTexture)
		glBindTexture(0, texture);
	glBindVertexArray(VAO);
	glDrawArrays(GL_TRIANGLES,0, 6);
	glBindVertexArray(0);
}
```

这样，我就可以简单地画一个正（长）方形了！

```C++
MyShader shader("vertex.vs", "fragment.fs");
shader.use();
	// 配置着色器projection
glm::mat4 projection = glm::ortho(0.0f, static_cast<GLfloat>(width),
	static_cast<GLfloat>(height), 0.0f, -1.0f, 1.0f);
shader.setMat4("projection", projection);
GameObject test;
Renderer renderer(shader);
test.addRenderer(renderer);
while (!glfwWindowShouldClose(window))
{
	glClearColor(0, 0.5, 0.5, 1.0);
	glClear(GL_COLOR_BUFFER_BIT);
	processInput(window);

	test.getRenderer().draw( glm::vec3(200, 200, 0), glm::vec2(300, 300), 0, glm::vec3(1.0, 0.4, 0.3));

	glfwSwapBuffers(window);
	glfwPollEvents();
};
```

> <img src="D:\my_game\MyEngine\log\正方形.jpg" alt="好欸，正方形" style="zoom:50%;" />

另外，renderer应该支持纹理。我为Renderer类提供了两个构造函数，分别是只有颜色的版本和支持纹理的版本。它们的主要区别在于enableTexture的值。

稍微修改片段着色器，就能得到一个支持两个版本的Renderer了！≥▽≤

<img src="D:\my_game\MyEngine\log\橙色的爱丽丝.jpg" alt="image-20230920193820320" style="zoom: 67%;" />

Renderer先到这里，去做下一个组件吧！

#### 2.4.2RigidBody刚体

##### 2.4.2.1总览

刚体，就是一个不会发生形变的物体。提到刚体，就不得不提物理了，因此我要在这里实现一些物理的东西。

之后，在渲染循环里面，这样：

```C++
while(1){
    ...
    Alice.getRigidBody().update();
    Alice.getRenderer().draw(RigidBody)//没错我打算把位置的信息也交给RigidBody管理
    ...
}
```

因为我是菜b，所以我先只考虑质点和重力

##### 2.4.2.2位置，质量，加速度和速度

```C++
class Rigidbody:
	public Component
{
	glm::vec2 position;
	glm::vec2 velocity;
	glm::vec2 acceleration;
	float weight;
	bool gravity;
	Rigidbody()=default;
	Rigidbody(glm::vec2 pp,glm::vec2 vv,glm::vec2 aa,float ww,bool gg);
	void update();
	void impact(glm::vec2 force);
};



Rigidbody::Rigidbody(glm::vec2 pp, glm::vec2 vv, glm::vec2 aa, float ww, bool gg)
{
	position = pp;
	velocity = vv;
	acceleration = aa;
	weight = ww;
	gravity = gg;
}
void Rigidbody::update()
{
	this->position += this->velocity * ENGINE_TICK_TIME;
	this->velocity += this->acceleration * ENGINE_TICK_TIME;
	this->acceleration = glm::vec2(0, 9.8);
}

void Rigidbody::impact(glm::vec2 force)
{
	this->acceleration = this->acceleration + (force / weight);
}

```

一个简单到不能再简单的实体写好啦

#### 2.4.3Collider 碰撞器

说实话我一开始毫无头绪，所以我决定求助于chatGPT先生

GPT先生告诉我要使用一个长方形把物体包裹起来。因为目前我的GameObject全都是方形，所以正好喵。

##### 2.4.3.-1但是，在此之前......

我们要重构一下代码，让GameObject尽量不用getRenderer().draw( gameobject.position,...)的方式来画一个物体，而是可以直接用

```C++
gameobject.draw();
```

的形式来画一个物体。

```
void GameObject::draw(glm::vec3 color)
{
	if (component[0]) {
		this->getRenderer().draw(position, size, angle, color);
	}
}

void GameObject::draw(float r, float g, float b)
{
	glm::vec3 color(r, g, b);
	this->draw(color);
}
```

##### 2.4.3.1Collider包围盒

```C++
struct Rect {
    float x, y, width, height;
};
class Collider :
    public Component
{
public:
    Rect collid_box;
    Collider();
    Collider(float x, float y, float width, float height);
    void adjustBox(float x, float y, float width, float height);
    bool isColliding(Collider co);
    bool isColliding(Rect rect);
};
```

我是用了一个结构体来充当包围盒，并定义了构造方法和最核心的检测碰撞方法。具体实现如下：

```C++
Collider::Collider()
{
	adjustBox(0,0,0,0);
}

Collider::Collider(float x, float y, float width, float height)
{
	adjustBox(x, y, width, height);
}

void Collider::adjustBox(float x, float y, float width, float height)
{
	collid_box.x = x;
	collid_box.y = y;
	collid_box.width = width;
	collid_box.height = height;
}

bool Collider::isColliding(Collider co)
{
	return isColliding(co.collid_box);
}

bool Collider::isColliding(Rect rect)
{
	Rect rect1 = collid_box,rect2 = rect;
	if (rect1.x < rect2.x + rect2.width &&
		rect1.x + rect1.width > rect2.x &&
		rect1.y < rect2.y + rect2.height &&
		rect1.y + rect1.height > rect2.y) {
		return true;
	}
	return false;
}
```

但愿这种调用自己重载的做法不会拖慢效率。

##### 2.4.3.2（并不）智能调整的碰撞器

```C++
void GameObject::addCollider(Collider c)
{
	component[2] = true;
	collider = c;
	collider.adjustBox(position.x, position.y, size.x, size.y);
}

void GameObject::addCollider(Collider c, float x, float y, float width, float height)
{
	component[2] = true;
	collider = c;
	collider.adjustBox(x, y, width, height);
}
```

我定义了两个addCollider方法，其中一个根据gameobject自身的情况来调整碰撞盒的大小，另一个则是由用户指定

至于碰撞后的行为嘛，先交给使用者来做啦（跑路）

##### 2.4.3.3使用例

我创建了一个爱丽丝和一个柚子，并给她们添加了碰撞器，之后我在主循环中控制，使得爱丽丝在碰到柚子之后停止运动

```C++
test.draw(0.5, 0.9f, 0.0);
		test.updateRigidbody();
		yuzi.draw(1.0,1.0,1.0);
		if (test.getCollider()->isColliding(*yuzi.getCollider())) {
			test.getRigidbody()->velocity = glm::vec2(0, 0);
			test.getRigidbody()->acceleration=glm::vec2(0,0);
		}
```

<center>
    <img style="border-radius: 20px;"
         src="D:\my_game\MyEngine\log\爱丽丝on柚子.png" 
         alt=""
         width="200" >
    <br>
    <div style="color: #999; padding: 2px;">
        她们太可爱了，简直就是小天使！
    </div>
</center>

你看，现在爱丽丝可以停在柚子头上了，太可爱了！（≥▽≤）

#### 2.4.4script 脚本

```C++
class Script :
    public Component
{
public:
    GameObject* myself;
    virtual void update();
    virtual void start();
};
```

我给脚本定义两个虚函数，方便用户编写各种各样的脚本。另外我提供立一个指向自己的指针myself，方便操作自己。之后我会定义一个指向整场游戏的指针thisgame。嘛，暂时先这样？

之后我给Alice写了一个脚本

```c++
void AliceScript::start() {
	myself->Translate(0, 300);
}
void AliceScript::update() {
	myself->Translate(5, 0);
}
```

这会让Alice移动到（0，300）的位置，然后每帧向右面走5个像素。

修改主函数，我们看看什么效果

##### 2.4.4.1 error C2143 & error C4430

呃，报C3646了，另有C2143 C4430成对出现。只要将Script类GameObject* myself 改成 class     GameObject* myself;就行了

**注意：这个错误的原因是我先声明的script，再声明的go，因此当处理到script的时候编译器还不知道GameObject类是什么，所以我要先加上一个class**

差点忘了，子类的虚函数应该由父类的指针调用，所以记得再GameObject里面定义一个Script的指针指向真正的脚本。

好了，现在我们看看结果：

```
	//定义爱丽丝
	GameObject alice;	
	alice.Scale(3, 3);

	Renderer renderer(shader, test_texture);
	alice.addRenderer(renderer);
	Collider testc;
	alice.addCollider(testc);
	AliceScript alicescript;
	alice.addScript(&alicescript);
	Rigidbody r;
	alice.addRigidbody(r);
	Collider alicec;
	alice.addCollider(alicec);

	//定义柚子
	GameObject yuzi;
	yuzi.Scale(3, 3);
	yuzi.Translate(0, 600);
	Renderer yrenderer(shader, yuzi_texture);
	yuzi.addRenderer(yrenderer);
	Collider yuzic;
	yuzi.addCollider(yuzic);
	
	//.....
	
	alice.getScript()->start();
	
	while (!glfwWindowShouldClose(window))
	{
		//...
		
		//更新所有物体的状态
		alice.draw(0.5, 0.9f, 0.0);
		alice.getScript()->update();
		alice.updateRigidbody();
		yuzi.draw(1, 1, 1);
		if (alice.getCollider()->isColliding(*yuzi.getCollider())) {
			cout << "撞上啦！" << endl;
		}
		else if(flag){
			flag = 0;
			cout << "分开啦!" << endl;
		}
		
		//...
	};
```



<center>
    <img style="border-radius: 20px;"
         src="D:\my_game\MyEngine\log\旅途的第一个终点.png" 
         alt=""
         width="1000" >
    <br>
    <div style="color: #999; padding: 2px;">
        四个组件已经齐全了！
    </div>
</center>

ok，那么功能层先这样，接下来可以进入资源层了。

## 3.资源层的开发

资源层的目的是把纹理、着色器统一地管理起来。

要把它们统一管理，就要先让它们统一，Shader已经封装了，那么剩下的工作就是

### 3.1封装Texture2D

我从网上抄了这段代码

```C++
Texture2D::Texture2D()
    : Width(0), Height(0), Internal_Format(GL_RGB), Image_Format(GL_RGB), Wrap_S(GL_REPEAT), Wrap_T(GL_REPEAT), Filter_Min(GL_LINEAR), Filter_Max(GL_LINEAR)
{
    glGenTextures(1, &this->ID);
}

void Texture2D::Generate(GLuint width, GLuint height, unsigned char* data)
{
    this->Width = width;
    this->Height = height;
    // Create Texture
    glBindTexture(GL_TEXTURE_2D, this->ID);
    glTexImage2D(GL_TEXTURE_2D, 0, this->Internal_Format, width, height, 0, this->Image_Format, GL_UNSIGNED_BYTE, data);
    // Set Texture wrap and filter modes
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, this->Wrap_S);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, this->Wrap_T);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, this->Filter_Min);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, this->Filter_Max);
    // Unbind texture
    glBindTexture(GL_TEXTURE_2D, 0);
}

void Texture2D::Bind() const
{
    glBindTexture(GL_TEXTURE_2D, this->ID);
}
```

接下来，稍微修改Renderer的代码，就可以当无事发生啦！

### 3.2ResourceManager

我创建了两个全局的Map

```
std::map<std::string, Texture2D>    ResourceManager::Textures;
std::map<std::string, MyShader>       ResourceManager::Shaders;
```

之后用ResourceManager类来行使创建材质和Shader的功能

```C++
MyShader ResourceManager::LoadShader(const GLchar* vShaderFile, const GLchar* fShaderFile, const GLchar* gShaderFile, std::string name)
{
    Shaders[name] = loadShaderFromFile(vShaderFile, fShaderFile, gShaderFile);
    return Shaders[name];
}

MyShader ResourceManager::GetShader(std::string name)
{
    return Shaders[name];
}

Texture2D ResourceManager::LoadTexture(const GLchar* file, GLboolean alpha, std::string name)
{
    Textures[name] = loadTextureFromFile(file, alpha);
    return Textures[name];
}

Texture2D ResourceManager::GetTexture(std::string name)
{
    return Textures[name];
}

void ResourceManager::Clear()
{
    // (Properly) delete all shaders	
    for (auto iter : Shaders)
        glDeleteProgram(iter.second.ID);
    // (Properly) delete all textures
    for (auto iter : Textures)
        glDeleteTextures(1, &iter.second.ID);
}

MyShader ResourceManager::loadShaderFromFile(const GLchar* vShaderFile, const GLchar* fShaderFile, const GLchar* gShaderFile)
{
    if (gShaderFile == nullptr) {
        MyShader shader(vShaderFile,fShaderFile);
        return shader;
    }
    else {
        MyShader shader(vShaderFile,fShaderFile,gShaderFile);
        return shader;
    }
}

Texture2D ResourceManager::loadTextureFromFile(const GLchar* file, GLboolean alpha)
{
    Texture2D texture;
    if (alpha)
    {
        texture.Internal_Format = GL_RGBA;
        texture.Image_Format = GL_RGBA;
    }
    // Load image
    int width, height, nrChannels;
    unsigned char* data = stbi_load(file, &width, &height, &nrChannels, 0);
    if (data)
    {
        texture.Generate(width, height, data);
    }
    else
    {
        std::cout << "Failed to load texture" << file << std::endl;
    }
    stbi_image_free(data);
    glBindTexture(GL_TEXTURE_2D, 0);
    return texture;
}
```

之后再主函数内进行一些替换，这下资源层也完事了，就是这么简单！

我突然有一个想法，既然这些材质和着色器可以这样管理，那么Unity里面的预制体，是不是也可以这样做呢？

于是，我们下一步就是：

## 4.预制体

预制体就是当我把一个GameObject装好之后，我可以把它扔进一个预制体堆（其实是红黑树）里面去，然后我可以通过initiate方法随时生成这个GameObject。

不同于ResourceManager整合了组装资源的过程，PrefabManager(暂时)只提供装预制体的功能

### 4.1管理预制体

```C++
std::map<std::string, GameObject> PrefabManager::Prefabs;

GameObject PrefabManager::LoadPrefab(GameObject go, std::string name)
{
    Prefabs[name] = go;
    return go;
}

GameObject PrefabManager::GetPrefab(std::string name)
{
    GameObject res = Prefabs[name];
    return res;
}
```

但是这样会有一个问题，就是script的myself还是会指向之前的GameObject，也就是指向那个原型。所以我们要重新生成一个脚本，使其myself指向新的GameObject。

当然可以这么做

```C++
xxxScript s;
GameObject x = PrefabManager::GetPrefab("xxx");
x.addScript(s);
```

但是这样耦合度就太高了，不利于之后统一管理所有GameObject，所以我才用另一种方法。

对于Script类，再定义一个虚函数

```
virtual Script* instance();   
```

它的子类实现是这样的

```C++
Script* AliceScript::instance()
{
	AliceScript *a = new AliceScript();
	return a;
}
```

没错，我在这里开辟了一个新的子类空间然后返回它的指针。不创建一个子类对象是因为对象会随着instance的结束而释放掉，这样的话指针将变得毫无意义。

然后我再GameObject定义了一个新的public方法

```C++
void GameObject::reLoadScript()
{
	if (component[3]) {
		scriptIsNewed = true;
		script = script->instance();
		script->myself = this;
	}
}
```

这样的话使用PrefabManager::GetPrefab()创建一个GameObject的时候，只需要手动调用新GameObject的reLoadScript方法就可以了。这有点像Java的反射机制。

另外，记得在GameObject里面加一个析构函数，如果脚本是用new生成的，那么要显式地删除脚本。

2023.11.10

我发现这种方法也不好，因为新的脚本也是由脚本的原件生成的，一旦“原件”丢失了，C++会自动帮我回收它生成的脚本，所以只要原件不在主函数里面，那么一样会出错，所以我干脆把脚本也统一管理。我在全局保存若干指向自定义脚本的指针，然后在定义一个GameObject的时候，我用全局的指针创建一个脚本。

我为每个自定义脚本都创建了这样的构造函数

```C++
HosinoScript::HosinoScript(GLFWwindow* w, std::string b):window(w),bullet(b)
{
	if (!PrefabManager::Scripts.count("HosinoScript")) {
		PrefabManager::LoadScript(this, "HosinoScript");//先放一个假的，防止无限递归
		static HosinoScript a(window,bullet);
		PrefabManager::LoadScript(&a, "HosinoScript");
	}
}
```

这样，在第一次创建自定义脚本对象的时候就会自动添加一个可以用同名找到的静态脚本对象。

因为这个“原件”是静态的，所以由它的instance方法创建的新脚本是不会被回收的。

这样也有坏处，就是自定义脚本有参数的时候，只会保留第一个定义的静态脚本对象，需要用户手动添加新的静态脚本。

不过，现在各个模块之间的耦合度更低了，代码更方便了，这是好事呀，好事。

2024.2.22

发生了很多事情，我会继续这个项目。

我还是觉得这个办法不好，因为需要程序员在写脚本的时候做很多事情，我会在之后的时间（也许是三月）里面使用c++实现一个反射技术来做这件事情，我们现在先关心其它功能罢。

### 4.2速通一个小demo

该有的都有了，我觉得可以做一个小东西来彰显游戏引擎的优越性了！

游戏名：《大蛇掀开被窝，发现里面全都是mika!》

游戏的玩法是，显示一只大蛇，点击大蛇，在随机位置生成一个mika。

#### 4.2.1制作预制体

我先制作一个大蛇和米卡的预制体

先做mika的，其实不需要脚本，但是为了表示多个预制体用一个脚本也ok，我给她用上了星野的脚本

```C++
GameObject makemika() {
	GameObject mika;
	Renderer r(ResourceManager::GetShader("characterShader"), ResourceManager::GetTexture("mikaTexture"));
	mika.addRenderer(r);
	HosinoScript s(window, "mika");
	mika.addScript("HosinoScript");
	mika.reLoadScript();
	PrefabManager::LoadPrefab(mika, "mika");
	return mika;
}
```

照葫芦画瓢可以写出大蛇的，这里只贴大蛇的脚本的update部分

```C++
void SnakeScript::update()
{	
	if (!pressed&&glfwGetKey(window, GLFW_KEY_F) == GLFW_PRESS) {
		pressed = true;
		GameObject temp = PrefabManager::GetPrefab("mika");
		temp.reLoadScript();
		temp.position = glm::vec2(rand() % 500, rand() % 500);
		mikas.push_back(temp);
		log(mikas.size());
	}
	if (pressed && glfwGetKey(window, GLFW_KEY_F) == GLFW_RELEASE) {
		pressed = false;
	}
	for (auto g : mikas) {
		g.draw(1, 1, 1);
		g.updateScript();
	}
}
//顺便一提，我在start方法里面设置了随机数种子
```

记得先做mika的预制体，再做大蛇的预制体

好了，现在我们可以快乐的按F来召唤mika攻击大蛇了！

<center>
    <img style="border-radius: 20px;"
         src="D:\my_game\MyEngine\log\《大蛇和mika》.jpg" 
         alt=""
         width="500" >
    <br>
    <div style="color: #999; padding: 2px;">
        >▽<
    </div>
</center>

不过按D的时候mika没有向右移动，这又涉及到脚本的问题，我很生气。

### 4.3预制体工厂

之前我们制作预制体的时候，都是从一个map里面拿一个出来，然后重新加载它的脚本。

我有一个想法，就是不储存一个现成的“原件“，而是保存”工序”，需要的时候按照这个工序制作一个就好了

C++提供了一个std::function来帮我们定义函数指针，就它了！

我用一个这样

```c++
static std::map<std::string, std::function<GameObject()> > PrefabFactory;
```

的map储存名字和制造工序的对应关系。

之后只需要调用MakePrefab方法，就能做出一只可口的预制体了！

我也不知道这么做有什么好处，先留着吧。

```C++
GameObject PrefabManager::MakePrefab(std::string name)
{
    return PrefabFactory[name]();
}
```

## 5.统一管理GameObject

之前的例子里，我通过在大蛇的脚本里面设置一群mika的方法来画出很多的mika，这对于引擎的使用者并不太友好。

我希望有一个统一的接口供程序员调用，使其可以向游戏全局里面添加GameObject。

### 5.1单例模式

我新学的！

因为我们只需要一个 东西 来管理GameObject，所以我要试试单例模式。

先来看看单例模式的统一操作

首先因为它只能有一个实例，因此就不能把它的构造函数暴露给用户

同时还要禁用拷贝构造和等于号。

```c++
private:
	static GameObjectManager* gomanager;
	GameObjectManager() {}
	GameObjectManager(const GameObjectManager& gm) = delete;
	GameObjectManager operator =(const GameObjectManager& x) = delete;
	static std::mutex gom_mutex;
```

其次给使用者提供一个拿到实例的静态方法。

```c++
GameObjectManager* GameObjectManager::getinstance()
{
    if (gomanager == nullptr) {
        std::lock_guard<std::mutex> m(gom_mutex);
        if (gomanager == nullptr) {
            gomanager = new GameObjectManager();
        }
    }
    return gomanager;
}
```

完美！

### 5.2常用功能

之后只需要实现常用的一些功能就好了。

```c++
void GameObjectManager::emplace_go(GameObject go)
{
    gos.emplace_back(std::move(go));
}

void GameObjectManager::draw_all()
{
    for (int i = 0; i < gos.size(); ++i) {
        gos[i].draw(1, 1, 1);
    }
}

void GameObjectManager::draw_all(float r, float g, float b)
{
    for (int i = 0; i < gos.size(); ++i) {
        gos[i].draw(r, g, b);
    }
}

void GameObjectManager::updateScript_all()
{
    for (int i = 0; i < gos.size(); ++i) {
        gos[i].updateScript();
    }
}

void GameObjectManager::uodateRigidbody_all()
{
    for (int i = 0; i < gos.size(); ++i) {
        gos[i].updateRigidbody();
    }
}
```

其中gos是一个vector数组。我觉得可以用左值引用和右值引用进行一波大优化，但是我打算之后再做这些事。

## 6.IO：鼠标和键盘

在之前的例子里面，我都使用glfw给我提供的函数来监听IO的输入，这有些麻烦，因为我的引擎锁30帧，这意味着一次输入可能会被当成很多次。现在我要自己写一个（当然还是基于glfw给我提供的函数）监听类，帮助我优化代码体验。

本章的目标demo是，制作出一个观赏鱼，点击观赏鱼会让她在屏幕范围内随即移动，按wasd或者上下左右可以朝固定方向移动

### 6.1键盘

我把每个按键绑定一个回调函数，储存在一个map里面。

同时另开一个数组，储存按键的状态。

#### 6.1.1基础模式

```c++
bool InputListener::addCallback(int ascii, std::function<void()> foo)
{
	callback[ascii] = foo;
	isPressed[ascii] = false;
	return true;
}

void InputListener::update()
{
	for (const auto& c : callback) {
		if (c.first < 8)  continue;
		if ((isPressed[c.first]==false)&&GetAsyncKeyState(c.first) & 0x8000) {
			c.second();
			isPressed[c.first] = true;
		}
		else if(!(GetAsyncKeyState(c.first)&0x8000)){
			isPressed[c.first] = false;
		}
	}
}
```

2024.3.1 跟莹酱表白了，好开心好开心好开心！

**#待改进**

我注意到这个储存按键状态的数组也可以是全局唯一的，而不用特地放在每个对象里面。我会在之后改进这个问题。

我向script类添加一个这个对象，用移动赋值的方式添加。这样应该就可以用了。

**#待改进**

这个函数目前还不能带参数，所以连最基础的改变自己都做不到，我之后会用bind来修正这个问题。

遇到了一些问题，好像不能把回调函数添加进去。

好吧原来是没在主函数里调用，我是傻逼。

```c++
void onD() {
	log("向右走！");
}
void HosinoScript::start(GameObject* me)
{
	inputListener.addCallback('D', onD);
}
```

<center>
    <img style="border-radius: 20px;"
         src="D:\my_game\MyEngine\log\向右走（伪）.jpg" 
         alt=""
         width="150" >
    <br>
    <div style="color: #999; padding: 2px;">
       	回调函数正常。。。。。。吗？
    </div>
</center>

#### 6.1.2使用bind给回调函数加参数

```c++
template<class F, class ...Args>
inline bool InputListener::addCallback(int ascii, F&& f, Args && ...args)
{
	callback[ascii] = std::bind(std::forward<F>(f), std::forward<Args>(args...));
	isPressed[ascii] = false;
	return false;
}
```

其中，std::bind会把我的函数和特定的参数绑定在一起，而这些特定的参数可以在添加回调的时候指定。

总之，bind是好文明

```c++
void onD(GameObject* me) {
	me->Translate(50, 0);
	log("向右走！");
}
void HosinoScript::start(GameObject* me)
{
	inputListener.addCallback('D', onD, me);
}
```

现在，hoshino真的可以向右走了！

<center>
    <img style="border-radius: 20px;"
         src="D:\my_game\MyEngine\log\小鸟游星野，站起来了！.jpg" 
         alt=""
         width="300" >
    <br>
    <div style="color: #999; padding: 2px;">
       	回调函数正常啦！
    </div>
</center>


### 6.2鼠标

#### 6.2.1侦测按键

单纯的侦测左键、右键、中键什么的是否被按下是很简单的，只需要把

```c++
if (c.first < 8)  continue;
```

这个我也不知道当时为什么要写的东西去掉就行了。

#### 6.2.2鼠标在物体上

我们经常需要鼠标在一个物体上的时候执行一些事情，这就需要我们知道鼠标的位置。

知道鼠标的位置需要一个“参考的窗口”，所以我需要随时传入这个窗口，这又会加大耦合。

所以我决定设置一个单例MousePos类，统一管理鼠标位置。

```c++
class MousePos
{
public:
	static MousePos* getinstance();
	void update(GLFWwindow*& window);
	double getx() { return x; }
	double gety() { return y; }
private:
	MousePos(){}
	MousePos(const MousePos& m) = delete;
	MousePos operator = (const MousePos& m) = delete;
	static double x, y;
	static MousePos* mousepos;
	static std::mutex mpos_mutex;
};
void MousePos::update(GLFWwindow*& window)
{
    glfwGetCursorPos(window, &x, &y);
}
```

之后，在InputListener中添加一个新方法，用于绑定“鼠标在物体上时”的函数

```c++
template<class F, class ...Args>
inline void InputListener::addMouseOn(F&& f, Args && ...args)
{
    hasMouseOn = true;
	mouseOn = std::bind(std::forward<F>(f), std::forward<Args>(args)...);
}
```

相应的也有“鼠标不在物体上时”的函数

我在InputListener的update方法里面添加了这部分的检测。

因为要用到物体信息，而InputListener是GameObject的一部分，所以不能传GameObject本身而要传物体的位置和尺寸

```c++
double x= MousePos::getinstance()->getx(), y= MousePos::getinstance()->gety();
	if (x >= pos.x && x <= pos.x + size.x && y >= pos.y && y <= pos.y + size.y) {
		if (hasMouseOn) {
			mouseOn();
		}
	}
	else {
		if (hasMouseNotOn) {
			mouseNotOn();
		}
	}
```

**#待改进**

我目前没有考虑旋转

```c++
void onMouse(GameObject* me) {
	me->Translate(0, 50);
	log("被鼠标碰到了！");
}
```

使用这个函数测试一下，hoshino立马把我当成下头男了捏（哇哇大哭）

<center>
    <img style="border-radius: 20px;"
         src="D:\my_game\MyEngine\log\星野躲避下头男.jpg" 
         alt=""
         width="500" >
    <br>
    <div style="color: #999; padding: 2px;">
       	星野你别走，我真不是下头男啊啊啊啊啊/(ㄒoㄒ)/~~
    </div>
</center>
### 6.3最终效果

```c++
void KokomiScript::onMouse()
{
	this->mouseFocus = true;
}

void KokomiScript::notOnMouse()
{
	this->mouseFocus = false;
}

void KokomiScript::onClick(GameObject* me)
{
	if (this->mouseFocus) {
		me->position = glm::vec2(rand() % 500, rand() % 500);
	}
}

void KokomiScript::start(GameObject* me)
{
	srand(time(0));
	inputListener.addCallback(1, &KokomiScript::onClick, this,me);
	inputListener.addMouseOn(&KokomiScript::onMouse,this);
	inputListener.addMouseNotOn(&KokomiScript::notOnMouse, this);
	inputListener.addCallback('W', [](GameObject* me) {
		me->Translate(0, -50);
		}, me);
	inputListener.addCallback('S', [](GameObject* me) {
		me->Translate(0, 50);
		}, me);
	inputListener.addCallback('A', [](GameObject* me) {
		me->Translate(-50, 0);
		}, me);
	inputListener.addCallback('D', [](GameObject* me) {
		me->Translate(50,0);
		}, me);
}
```

我创建了一些函数，然后把他们添加进对应的回调（其中键盘控制的回调函数我用了lambda表达式），注意使用类函数的时候，要在填写参数的位置填上隐式的this指针

<center>
    <img style="border-radius: 20px;"
         src="D:\my_game\MyEngine\log\游动的观赏鱼.png" 
         alt=""
         width="700" >
    <br>
    <div style="color: #999; padding: 2px;">
       	（应该）可以看到心海的位置在点击时随即移动，在键盘操作时规律移动
    </div>
</center>

（顺便一提输出位置的函数的名字叫whatCanISay，致敬传奇曼巴精神）

## 7.发射！

好吧我本来想在这一节写反射的，但是我觉得现在的脚本貌似还挺好使，所以我决定先补充碰撞器的一些方法。

我要补充有关碰撞器的方法，使得用户可以只关注碰撞之后的事情，而不用关心如何检测这些碰撞。

最终我要实现的小demo是：按J键让米卡发射子弹，击中大蛇后大蛇和子弹一起消失。

### 7.1onColliderEnter

这个函数可以用来检测本GameObject有没有和另一个带有collider的GameObject碰撞，它提供一个参数collider，代表与其相撞的GameObject。通过这个collider，我可以访问到对方Game Object的信息，所以我要向Collider中添加一个成员，我要通过它访问到一个GameObject。

答案是一个指向所属gameobject的指针！虽然我觉得指针用得太多了，但是我还想不到有什么更好的方法。

和脚本一样，这个gameObject的指针指向的东西随时会变化，但是我想让它一直指向“自己”。怎么办呢？我想到了一个与当时脚本不同的解决方案：名字。

#### 7.1.1名字系统

我将GameObjectManager里面的go数组改成了一个map，这样我就可以通过一个id，也就是名字来访问各个object了，相应的对应的方法也应当改变。

那么，这个id如何确认呢？

我想使用一个计数器，这样就可以保证每个go的id都不同。

**#待改进：**mysql似乎还有一种雪花算法，我也许可以提供这个选项

```c++
void GameObjectManager::emplace_go(GameObject go)
{
    ++idCounter;
    go.getCollider()->gameObjectID = idCounter;
    go.name = go.name + std::to_string(idCounter);
    gos.insert(std::pair<int,GameObject>(idCounter,std::move(go)));
}
```

在添加go的时候，设定一个全局唯一的id，赋给collider，这样就ok了，当然也可以用作脚本，但是脚本已经写好了不太想改（咸鱼）

之后给collider添加一个getObject方法

```c++
GameObject& Collider::getObject()
{
	return GameObjectManager::getinstance()->getObject(gameObjectID);
}

```

这样就ok了。

测试一下，我们用上一个demo，修改whatCanISay函数,让它

```
log(me->getCollider()->getObject().name);
```

用这种方法输出自己的名字，发现正确的显示了名字和id，好耶！

#### 7.1.2基类的虚函数

```c++
void Script::onColliderEnter(GameObject* me,Collider& co)
{
}
```

同脚本家系基类的其他函数，onColliderEnter是一个虚函数，传两个参数，一个是GameObject的指针，另一个是对方的碰撞器。

话说...为什么不直接传对方的go啊

#### 7.1.3触发方式

```c++
for (auto& id_go : gos) {
        id_go.second.updateScript();
        Collider* now = id_go.second.getCollider();
        if (now) {
            for (auto& id_go2 : gos) {
                if (&id_go == &id_go2) continue;//加了这句就对了www
                Collider* temp = id_go2.second.getCollider();
                if (temp->isColliding(*id_go.second.getCollider())) {
                    id_go.second.getScript()->onColliderEnter(&id_go.second,*temp);
                }
            }
        }
    }
```

我用了双重循环，这样小率很低，先这样吧，以后再优化欸嘿。

据说就是因为检测碰撞很复杂所以才有了四叉树和八叉树，唔姆，看来迟早要写。

这段代码看起来正确，实际上由于我是cb，在更新位置的时候忘记了更新碰撞箱，所以这个东西实际上没有什么用。

现在有两个解决方法，第一个是在每次检测碰撞是时候都更新碰撞箱，另一个是重新写位置移动的东西，把position装到一个类里面，然后重载赋值操作。为了后面的事情考虑，还是第二种方法吧（哭）。

好吧其实是一直在判断自己和自己有没有碰撞，乐。

我又修改了onCollider函数的触发方式，现在它会先检测碰在一起的go对，统一储存起来，统一触发onCollider函数。

### 7.2销毁

销毁一个物体很简单，因为我已经把所有的go统一管理了，并且使用ID给他们标号，所以我只要通知一下GameObjectManager要销毁的ID就可以了。

注意，如果已通知就销毁的话，会导致当前正在运行的update_all操作的迭代器出现异常，所以要先暂存待销毁的ID，update之后统一销毁

```c++
//GameObjectManager::updateScript_all()
//...update已经完成
for (auto id : destroyBuf) {
        gos.erase(id);
}
//...
void GameObjectManager::deleteGo(int ID)
{
    destroyBuf.emplace_back(ID);
}
void GameObject::Destroy()
{
	if (component[3]) {
		script->onDestroy(this);
	}
	GameObjectManager::getinstance()->deleteGo(ID);
}
```

## 8.消息系统

当一个物体要操纵其他物体的时候，总归要通过某种方式“通知”被操作的物体，这是很麻烦的，尤其是虫群的女王被击败的时候，她可能没那么多时间通知她成千上万的孩子们。

所以就有了伟大的消息系统！当女王死的时候，她会向消息系统里面发一个“manba out”的消息，她的孩子们看到消息的时候，就可以直接死了。这样女王可以专心的死，而不用一个一个的通知孩子们。

本章的目标demo是：我们点击一个学生，其它学生就会消失，留下为师和那个学生贴贴~

### 8.1MessageBox

显然天下的GO共用一个消息盒子，所以它应该是一个单例，不过，在设计消息盒子之前，我们要先设计：

#### 8.1.1E_Message类

现实世界里，我们是通过什么来判断快递是不是发给自己的呢？

答案是名字、手机号这种判断身份的id。不过我认为，既然消息系统的存在就是为了不用填写收件人而存在的，所以，只需要著名发件人的id就好了。

另外，E_Message的内容必然有消息的内容，即一个字符串，我希望是一个字符串，我想不到简单或者更好的方式了，可能会有需要，但我不在乎，这只是一个本科生的毕设。

最后，E_Message的意思是（Engine Message）

```C++
class E_Message
{
private:
	int sender_id;
	std::string content;
public:
	E_Message(int ss, std::string cc);
	int get_sender_id();
	std::string get_content();
};
```

很简单对吧，我觉得这两个属性足以表示一个消息，完成它的功能，这又不是数据库，不需要那么多东西

#### 8.1.2选择邮箱

想想使用场景：一个物体会向邮箱里面塞消息，而其它的会打开邮箱读取它（们）想要的信息

每个周期结束的时候，我会清除这些消息（想到有些消息可能会保持地长一点，日后可能会给消息添加一个过期时间之类的，现在先算了）

也就是说，这个数据结构要能够快速的添加和查找，考虑到以后的过期机制，也得支持遍历

那么，那种数据结构最合适呢？答案是集合，set，为了使用set存储E_Message，我需要重载E_Message的小于号。

#### 8.1.3实现

邮箱的状态是每帧更新的，也就是说，它的行为在某种程度上和一个普通的游戏物体是一样的。

那么，把它当作一个GameObject如何呢？我觉得不好，因为他可能不受全局的控制，而且也不太方便访问。

所以我打算把它当成一个单例。

```C++
//这里是绘制并更新GameObject的地方
		GameObjectManager::getinstance()->draw_all();

		GameObjectManager::getinstance()->updateScript_all();
```

这里是每一帧GoManager的动作，显然消息的清空应该发生在中间空着的那一行。

首先，应该有一个方法往里面添加消息。

```C++
bool MessageBox::put_message(E_Message e_m)
{
	_message_box.insert(e_m);
	return true;
}
```

之后，有一个方法得到信箱，就是直接返回那个set的引用

最后，是清理信箱的方法，直接调用set的clear()就可以了，在主循环中清空

```C++
//这里是绘制并更新GameObject的地方
		GameObjectManager::getinstance()->draw_all();
		EMessageBox::get_instance()->clear_message();
		GameObjectManager::getinstance()->updateScript_all();
```



### 8.2 Bug记录

#### 8.2.1名字

MessageBox是windows的一个名字，会直接狠狠报错，所以后面改成了EMessageBox，嘿嘿

#### 8.2.2运行逻辑

发现了一个有趣的bug

我在生成四个杂鱼之后，用这段代码判断信箱里有没有其它杂鱼生成的sensai消息

```C++
for (E_Message message : EMessageBox::get_instance()->get_box()) {
		if (message.get_content() == "I want sensai!" && message.get_sender_id() != me->ID) {
			me->Destroy();
		}
	}
```

看起来没什么问题，实际上**这段代码**确实没有问题，但是在运行的过程中，发生了一个很有趣的现象：ID小的杂鱼可以消除ID大的杂鱼，但是反过来就不行，难道杂鱼也论资排辈吗？

其实并不是，我们可以捋一捋逻辑

1）ID为1的杂鱼被update，她不往里添加信息

2）ID为2的杂鱼被update，她往里添加了消息

3）ID为3的杂鱼被update，她看到了消息，紫砂了

4）消息被主循环中的clear调用清空

到最后，ID为1的杂鱼根本看不到消息！所以说，消息的添加应该与GO的ID无关，也就是与她被加进游戏的时间无关，也就是与**她被update的时间**无关

所以，我想到一个方法，在put_message的时候，先将message扔到一个缓冲区buffer，在调用clear的时候，buffer中的消息会进入到真正的信箱里面，这样就避免了不同的GO因为update时机的不同导致的bug。

```C++
bool EMessageBox::put_message(E_Message e_m)
{
	_buffer.insert(e_m);
	return true;
}

void EMessageBox::clear_message()
{
	_message_box.clear();
	for (E_Message message : _buffer) {
		_message_box.insert(message);
	}
	_buffer.clear();
}
```

### 8.3最终效果

只有最主动的杂鱼酱可以独占sensai哦~